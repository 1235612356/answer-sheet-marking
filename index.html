<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>答题卡自动批阅（前端版）</title>
  <style>
    :root {
      --bg: #f4f5fb;
      --card-bg: #ffffff;
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --border: #e2e8f0;
      --text-main: #0f172a;
      --text-sub: #64748b;
      --danger: #dc2626;
      --accent: #22c55e;
      --warning: #f59e0b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #e0f2fe 0, #f4f5fb 40%, #f4f5fb 100%);
      color: var(--text-main);
    }

    h1 {
      margin: 0 0 16px;
      font-size: 22px;
      font-weight: 600;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    h1 span.sub {
      font-size: 13px;
      color: var(--text-sub);
      font-weight: 400;
    }

    h2 {
      margin: 0 0 8px;
      font-size: 15px;
      font-weight: 600;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }

    .panel {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 14px 16px 16px;
      box-shadow:
        0 12px 30px rgba(15, 23, 42, 0.06),
        0 0 0 1px rgba(148, 163, 184, 0.15);
      flex: 1 1 340px;
      min-width: 320px;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .panel-header h2 {
      margin-bottom: 0;
    }

    label {
      display: block;
      margin: 6px 0 2px;
      font-size: 12px;
      color: var(--text-sub);
    }

    input[type="text"],
    input[type="number"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      padding: 6px 8px;
      font-size: 13px;
      border-radius: 6px;
      border: 1px solid var(--border);
      outline: none;
      transition: border-color 0.15s, box-shadow 0.15s, background-color 0.15s;
      background-color: #f9fafb;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="password"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.2);
      background-color: #ffffff;
    }

    textarea {
      resize: vertical;
      min-height: 60px;
    }

    input[type="file"] {
      font-size: 12px;
      margin-top: 4px;
    }

    button {
      margin-top: 8px;
      margin-right: 6px;
      padding: 6px 12px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid transparent;
      background: var(--primary);
      color: #fff;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background-color 0.15s, box-shadow 0.15s, transform 0.05s, border-color 0.15s, color 0.15s;
      white-space: nowrap;
    }

    button.primary {
      background: var(--primary);
      border-color: var(--primary);
      color: #fff;
    }

    button.primary:hover:not(:disabled) {
      background: var(--primary-hover);
      border-color: var(--primary-hover);
      box-shadow: 0 5px 14px rgba(37, 99, 235, 0.3);
      transform: translateY(-0.5px);
    }

    button.secondary {
      background: #ffffff;
      border-color: var(--border);
      color: var(--text-main);
    }

    button.secondary:hover:not(:disabled) {
      background: #f8fafc;
      border-color: #cbd5f5;
      box-shadow: 0 3px 10px rgba(148, 163, 184, 0.25);
    }

    button.ghost {
      background: transparent;
      border-color: transparent;
      color: var(--text-sub);
      padding-left: 2px;
      padding-right: 2px;
    }

    button.ghost:hover:not(:disabled) {
      color: var(--text-main);
      background: rgba(148, 163, 184, 0.15);
    }

    button.small {
      font-size: 12px;
      padding: 4px 9px;
    }

    button.danger {
      border-color: var(--danger);
      color: var(--danger);
      background: #fff;
    }

    button.danger:hover:not(:disabled) {
      background: #fef2f2;
      border-color: #b91c1c;
      color: #b91c1c;
    }

    button:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    #log {
      font-family: Menlo, Consolas, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: 190px;
      overflow: auto;
      background: #020617;
      color: #e5e7eb;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #0f172a;
    }

    #log::-webkit-scrollbar {
      width: 7px;
    }
    #log::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 10px;
    }

    #answerSheetContainer {
      position: relative;
      display: inline-block;
      max-width: 100%;
      border-radius: 8px;
      overflow: hidden;
      background: #000;
    }

    #answerCanvas,
    #overlayCanvas {
      display: block;
      max-width: 100%;
      height: auto;
    }

    #overlayCanvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
    }

    #selectedAreaImage {
      max-width: 100%;
      border-radius: 6px;
      border: 1px solid var(--border);
      margin-bottom: 6px;
      display: block;
    }

    .small {
      font-size: 12px;
      color: var(--text-sub);
    }

    .tag {
      display: inline-flex;
      align-items: center;
      padding: 1px 7px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--border);
      background: #f8fafc;
      color: var(--text-sub);
      gap: 4px;
    }

    .tag.dot::before {
      content: "";
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .config-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }

    .config-row > div {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    #gradedSheetPreview {
      max-width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border);
      margin-top: 4px;
    }

    .file-list {
      margin-top: 4px;
      font-size: 12px;
      color: var(--text-sub);
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }

    .file-item button {
      margin-top: 0;
      padding: 2px 6px;
      font-size: 11px;
    }

    /* 题目方块网格 */
    .questions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .question-card {
      background: #fff;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      position: relative;
      min-height: 70px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .question-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    .question-card.selected {
      outline: 3px solid var(--primary);
      outline-offset: 2px;
    }

    .question-card .question-number {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-sub);
      margin-bottom: 4px;
    }

    .question-card .question-score {
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .question-card .question-type {
      font-size: 9px;
      color: var(--text-sub);
      text-align: center;
      margin-top: 2px;
    }

    /* 总分进度条 */
    .score-progress-container {
      margin: 16px 0;
      padding: 16px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    }

    .score-progress-bar {
      width: 100%;
      height: 40px;
      background: linear-gradient(to right, #ef4444, #f59e0b, #22c55e);
      border-radius: 20px;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .score-progress-fill {
      height: 100%;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      transition: width 0.5s ease;
      position: relative;
    }

    .score-progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }

    .score-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 13px;
      color: var(--text-sub);
    }

    /* 模态框样式 */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: #fff;
      margin: 5% auto;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.15);
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow: auto;
      position: relative;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 18px;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-sub);
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-button:hover {
      color: var(--text-main);
      background: rgba(148, 163, 184, 0.15);
      border-radius: 50%;
    }

    .modal-textarea {
      width: 100%;
      min-height: 200px;
      font-family: Menlo, Consolas, monospace;
      font-size: 13px;
      line-height: 1.5;
    }

    .input-group {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .input-group > div {
      flex: 1;
    }

    @media (max-width: 900px) {
      body {
        padding: 10px;
      }
      .panel {
        box-shadow:
          0 6px 14px rgba(15, 23, 42, 0.06),
          0 0 0 1px rgba(148, 163, 184, 0.1);
      }
      .modal-content {
        width: 95%;
        margin: 10% auto;
      }
      .questions-grid {
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      }
    }
  </style>
</head>
<body>
<h1>
  答题卡自动批阅
  <span class="sub">前端单页版 · 支持多张答题卡 · 智能选择题判分 · JSON 存档与重放</span>
</h1>

<div class="container">
  <!-- 配置面板 -->
  <div class="panel" style="max-width: 440px;">
    <div class="panel-header">
      <h2>1. 接口 & 模型配置</h2>
      <div class="config-row">
        <button id="saveSettingsButton" class="ghost small">保存设置</button>
        <button id="clearSettingsButton" class="ghost small">清除</button>
      </div>
    </div>

    <label>API Base URL（OpenAI 兼容接口）</label>
    <input id="apiBaseUrl" type="text"
           placeholder="例如：https://dashscope.aliyuncs.com/compatible-mode/v1" />

    <label>API Key（保存在浏览器本地，仅本机可见）</label>
    <input id="apiKey" type="password" placeholder="在此填写你的 API Key" />

    <h2 style="margin-top:14px;">2. 批阅模式</h2>

    <label>
      <input type="radio" name="mode" value="two-step" checked>
      两阶段：VL OCR 提取文字 + 文本模型批阅
    </label>
    <div id="twoStepConfig" style="margin-left: 16px; margin-bottom: 4px;">
      <label>参考答案 OCR 模型（VL）</label>
      <input id="referenceOcrModel" type="text" placeholder="例如：qwen-vl-ocr-latest" />
      <label>答题区域 OCR 模型（VL）</label>
      <input id="answerOcrModel" type="text" placeholder="例如：qwen-vl-ocr-latest" />
      <label>批阅模型（文本）</label>
      <input id="textGradingModel" type="text" placeholder="例如：deepseek-v3.1" />
    </div>

    <label>
      <input type="radio" name="mode" value="single-vl">
      单一 VL 模型看图批阅（图像 + 参考答案文字）
    </label>
    <div id="singleVlConfig" style="margin-left: 16px; display:none; margin-bottom: 4px;">
      <label>参考答案 OCR 模型（VL，可选）</label>
      <input id="referenceOcrModelVl" type="text" placeholder="例如：qwen-vl-ocr-latest" />
      <label>批阅模型（VL）</label>
      <input id="vlGradingModel" type="text" placeholder="例如：qwen2.5-vl-max 或 gpt-4o" />
    </div>

    <h2 style="margin-top:14px;">3. 图片上传</h2>
    
    <label>学生答题卡图片（可多选，按顺序批阅）</label>
    <input id="answerImageInput" type="file" accept="image/*" multiple />
    <div id="answerFileList" class="file-list"></div>

    <div class="input-group">
      <div>
        <label>批阅题数（从第1题开始）</label>
        <input id="questionCount" type="number" min="1" value="12" placeholder="例如：12" />
      </div>
    </div>

    <label>参考答案图片（可选，可多选，按序识别）</label>
    <input id="referenceImageInput" type="file" accept="image/*" multiple />
    <div id="referenceFileList" class="file-list"></div>

    <label>手动填写参考答案文本（优先使用此处文本）</label>
    <textarea id="referenceTextManual" placeholder="也可以直接把整份参考答案文本粘贴到这里"></textarea>

    <div style="margin-top: 8px; display:flex; flex-wrap:wrap; gap:6px;">
      <button id="showReferenceTextButton" class="secondary small">查看识别的总参考答案</button>
      <button id="saveReferenceTextButton" class="secondary small">保存参考答案文本</button>
    </div>

    <label style="margin-top: 8px;">
      <input id="enableAlign" type="checkbox" checked>
      启用右上角黑块自动对齐
    </label>

    <div style="margin-top: 12px; display:flex; flex-wrap:wrap; gap:6px;">
      <button id="startButton" class="primary">开始批阅</button>
      <button id="downloadJsonButton" class="secondary" disabled>下载 JSON 结果</button>
      <button id="downloadGradedSheetButton" class="secondary" disabled>下载批阅后答题卡</button>
      <button id="downloadTemplatePdfButton" class="secondary">下载标准答题卡（PDF）</button>
    </div>
    
    <label>注意打印答题卡时选择实际/100%大小，进行扫描时使用 300dpi</label>

    <h2 style="margin-top:16px;">4. 加载已有 JSON 结果</h2>
    <label>从本地文件加载 JSON 结果</label>
    <input id="jsonFileInput" type="file" accept="application/json" />
    <div class="small" style="margin-top:4px;">
      也可将 JSON 放在同一目录，通过链接参数 <code>?file=xxx.json</code> 打开页面
    </div>
  </div>

  <!-- 答题卡展示 + 日志 -->
  <div class="panel">
    <div class="panel-header">
      <h2>答题卡预览</h2>
      <span class="tag dot">实时对齐 & 区域查看</span>
    </div>
    <div id="answerSheetContainer">
      <canvas id="answerCanvas"></canvas>
      <canvas id="overlayCanvas"></canvas>
    </div>

<div style="display:flex; flex-direction:column; gap:4px; align-items:center;">
  <select id="gradedModeSelect" style="padding:3px 6px; font-size:11px;">
    <option value="sheet">带背景</option>
    <option value="scores">仅评分</option>
  </select>
  <img id="gradedSheetPreview" alt="批阅后答题卡预览" style="border:1px solid #ddd;"/>
</div>

    <div class="panel-header" style="margin-top: 14px;">
      <h2>运行日志</h2>
      <span class="small">用于调试模型调用、OCR 与批阅过程</span>
    </div>
    <div id="log"></div>
  </div>

  <!-- 结果展示 -->
  <div class="panel">
    <div class="panel-header">
      <h2>批阅结果</h2>
    </div>

    <!-- 总分进度条 -->
    <div class="score-progress-container">
      <div class="score-progress-bar">
        <div class="score-progress-fill" id="scoreProgressFill"></div>
        <div class="score-progress-text" id="scoreProgressText">0 / 0</div>
      </div>
      <div class="score-stats">
        <span id="scoreStatsLeft">得分率: 0%</span>
        <span id="scoreStatsRight">已批阅: 0 题</span>
      </div>
    </div>

    <!-- 题目方块网格 -->
    <div class="questions-grid" id="questionsGrid"></div>

    <h2 style="margin-top: 12px;">选中题目详情</h2>
    <div class="small" id="selectedQuestionInfo">
      点击上方某个题目方块查看详细信息
    </div>
    <img id="selectedAreaImage" alt="答题区域预览" />
    <label>学生作答内容</label>
    <textarea id="selectedAreaText" readonly></textarea>
    <label>AI 评分说明</label>
    <textarea id="selectedAreaComment" readonly></textarea>
    <label>区域整体评价</label>
    <textarea id="selectedOverallComment" readonly></textarea>
  </div>
</div>

<!-- 参考答案文本模态框 -->
<div id="referenceTextModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>识别的总参考答案文本</h2>
      <button class="close-button" id="closeReferenceModal">&times;</button>
    </div>
    <textarea id="referenceTextDisplay" class="modal-textarea" readonly></textarea>
    <div style="margin-top: 12px; display:flex; justify-content: flex-end; gap: 6px;">
      <button id="copyReferenceTextButton" class="secondary small">复制文本</button>
      <button id="closeReferenceTextModal" class="primary small">关闭</button>
    </div>
  </div>
</div>

<script>
  // ===== 题目区域与黑块参考位置 =====
  const QUESTION_AREAS = [
    {id: 1, x1: 58,   y1: 288,  x2: 1188, y2: 800},
    {id: 2, x1: 58,   y1: 795,  x2: 1188, y2: 1304},
    {id: 3, x1: 58,   y1: 1300, x2: 1188, y2: 1808},
    {id: 4, x1: 58,   y1: 1806, x2: 1188, y2: 2314},
    {id: 5, x1: 58,   y1: 2308, x2: 1188, y2: 2818},
    {id: 6, x1: 58,   y1: 2816, x2: 1188, y2: 3338},
    {id: 7, x1: 1264, y1: 288,  x2: 2394, y2: 800},
    {id: 8, x1: 1264, y1: 795,  x2: 2394, y2: 1304},
    {id: 9, x1: 1264, y1: 1300, x2: 2394, y2: 1808},
    {id:10, x1: 1264, y1: 1806, x2: 2394, y2: 2314},
    {id:11, x1: 1264, y1: 2308, x2: 2394, y2: 2818},
    {id:12, x1: 1264, y1: 2816, x2: 2394, y2: 3338},
  ];
  const REF_BLACK_BLOCK_POS = {x: 2266, y: 172};
  const SETTINGS_KEY = 'answerGraderSettings_v2';

  // ===== DOM 引用 =====
  const apiBaseUrlInput = document.getElementById('apiBaseUrl');
  const apiKeyInput = document.getElementById('apiKey');
  const referenceOcrModelInput = document.getElementById('referenceOcrModel');
  const referenceOcrModelVlInput = document.getElementById('referenceOcrModelVl');
  const answerOcrModelInput = document.getElementById('answerOcrModel');
  const textGradingModelInput = document.getElementById('textGradingModel');
  const vlGradingModelInput = document.getElementById('vlGradingModel');
  const modeRadios = document.querySelectorAll('input[name="mode"]');

  const answerImageInput = document.getElementById('answerImageInput');
  const answerFileList = document.getElementById('answerFileList');
  const questionCountInput = document.getElementById('questionCount');
  const referenceImageInput = document.getElementById('referenceImageInput');
  const referenceFileList = document.getElementById('referenceFileList');
  const referenceTextManualInput = document.getElementById('referenceTextManual');
  const enableAlignCheckbox = document.getElementById('enableAlign');

  const startButton = document.getElementById('startButton');
  const downloadJsonButton = document.getElementById('downloadJsonButton');
  const downloadGradedSheetButton = document.getElementById('downloadGradedSheetButton');
  const downloadTemplatePdfButton = document.getElementById('downloadTemplatePdfButton');
  const jsonFileInput = document.getElementById('jsonFileInput');
  const saveSettingsButton = document.getElementById('saveSettingsButton');
  const clearSettingsButton = document.getElementById('clearSettingsButton');
  
  const showReferenceTextButton = document.getElementById('showReferenceTextButton');
  const saveReferenceTextButton = document.getElementById('saveReferenceTextButton');

  const logDiv = document.getElementById('log');
  const answerCanvas = document.getElementById('answerCanvas');
  const overlayCanvas = document.getElementById('overlayCanvas');
  const gradedSheetPreview = document.getElementById('gradedSheetPreview');

  const questionsGrid = document.getElementById('questionsGrid');
  const scoreProgressFill = document.getElementById('scoreProgressFill');
  const scoreProgressText = document.getElementById('scoreProgressText');
  const scoreStatsLeft = document.getElementById('scoreStatsLeft');
  const scoreStatsRight = document.getElementById('scoreStatsRight');

  const selectedQuestionInfo = document.getElementById('selectedQuestionInfo');
  const selectedAreaImage = document.getElementById('selectedAreaImage');
  const selectedAreaText = document.getElementById('selectedAreaText');
  const selectedAreaComment = document.getElementById('selectedAreaComment');
  const selectedOverallComment = document.getElementById('selectedOverallComment');

  const twoStepConfig = document.getElementById('twoStepConfig');
  const singleVlConfig = document.getElementById('singleVlConfig');

  const referenceTextModal = document.getElementById('referenceTextModal');
  const referenceTextDisplay = document.getElementById('referenceTextDisplay');
  const copyReferenceTextButton = document.getElementById('copyReferenceTextButton');
  const closeReferenceTextModal = document.getElementById('closeReferenceTextModal');
  const closeReferenceModal = document.getElementById('closeReferenceModal');

  // ===== 全局状态 =====
  let answerSheetDataUrls = [];
  let referenceImageDataUrls = [];
  let allAreaImages = [];
  let gradingResult = null;
  let currentQuestionList = [];
  let selectedCardElement = null;
  let gradedSheetDataUrls = [];
  let gradedScoreOnlyDataUrls = [];
  let currentReferenceText = '';
  let areaImagesMap = new Map(); // 用于存储旧格式的区域图片 id -> image

  // ===== 工具函数 =====
  function log(msg) {
    const time = new Date().toISOString().substring(11, 19);
    logDiv.textContent += `[${time}] ${msg}\n`;
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(reader.error);
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });
  }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  function drawImageToCanvas(img, canvas) {
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
  }

  function syncOverlayCanvasSize() {
    overlayCanvas.width = answerCanvas.width;
    overlayCanvas.height = answerCanvas.height;
  }

  function clearOverlay() {
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  }

  function drawAreaHighlight(area) {
    clearOverlay();
    if (!area) return;
    const ctx = overlayCanvas.getContext('2d');
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 4;
    ctx.strokeRect(area.x1, area.y1, area.x2 - area.x1, area.y2 - area.y1);
  }

  // 更新文件列表显示
  function updateFileList(input, container) {
    const files = input.files;
    container.innerHTML = '';
    
    if (files.length === 0) {
      container.innerHTML = '<div class="small">未选择文件</div>';
      return;
    }
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const fileItem = document.createElement('div');
      fileItem.className = 'file-item';
      
      const fileName = document.createElement('span');
      fileName.textContent = `${i + 1}. ${file.name}`;
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'ghost small danger';
      removeBtn.textContent = '移除';
      removeBtn.onclick = (e) => {
        e.preventDefault();
        removeFile(input, i);
      };
      
      fileItem.appendChild(fileName);
      fileItem.appendChild(removeBtn);
      container.appendChild(fileItem);
    }
  }

  function removeFile(input, index) {
    const dt = new DataTransfer();
    const files = input.files;
    
    for (let i = 0; i < files.length; i++) {
      if (i !== index) {
        dt.items.add(files[i]);
      }
    }
    
    input.files = dt.files;
    if (input === answerImageInput) {
      updateFileList(input, answerFileList);
    } else if (input === referenceImageInput) {
      updateFileList(input, referenceFileList);
    }
  }

  // 显示参考答案文本模态框
  function showReferenceTextModal() {
    if (!currentReferenceText) {
      alert('当前没有识别的参考答案文本。请先完成批阅或加载已有结果。');
      return;
    }
    
    referenceTextDisplay.value = currentReferenceText;
    referenceTextModal.style.display = 'block';
  }

  // 关闭模态框
  function closeModal(modal) {
    modal.style.display = 'none';
  }

  // 复制参考答案文本
  function copyReferenceText() {
    referenceTextDisplay.select();
    document.execCommand('copy');
    
    const originalText = copyReferenceTextButton.textContent;
    copyReferenceTextButton.textContent = '已复制!';
    setTimeout(() => {
      copyReferenceTextButton.textContent = originalText;
    }, 2000);
  }

  // 保存参考答案文本
  function saveReferenceText() {
    if (!currentReferenceText) {
      alert('当前没有识别的参考答案文本。');
      return;
    }
    
    const ts = new Date().toISOString().replace(/[:.-]/g, '').slice(0, 15);
    const filename = `reference_text_${ts}.txt`;
    const blob = new Blob([currentReferenceText], { type: 'text/plain' });
    downloadBlob(blob, filename);
    
    log('已保存参考答案文本到本地文件。');
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // 黑块检测
  function detectBlackBlock(canvas) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    if (width === 0 || height === 0) return null;

    const yMax = Math.floor(height / 12);
    const xMin = Math.floor(width * 5 / 6);
    const w = width - xMin;
    const h = yMax;
    if (w <= 0 || h <= 0) return null;

    const imgData = ctx.getImageData(xMin, 0, w, h);
    const data = imgData.data;
    let minX = w, maxX = -1, minY = h, maxY = -1;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = (y * w + x) * 4;
        const r = data[idx];
        const g = data[idx + 1];
        const b = data[idx + 2];
        const v = (r + g + g + b) >> 2;
        if (v < 60) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }
    if (maxX < 0) return null;
    const centerX = xMin + (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    return {x: centerX, y: centerY};
  }

  function alignCanvas(canvas) {
    if (!enableAlignCheckbox.checked) {
      return;
    }
    const pos = detectBlackBlock(canvas);
    if (!pos) {
      log('警告：未检测到定位黑块，跳过对齐。');
      return;
    }
    const dx = REF_BLACK_BLOCK_POS.x - pos.x;
    const dy = REF_BLACK_BLOCK_POS.y - pos.y;
    log(`检测到黑块位置 (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}), 平移偏移量 dx=${dx.toFixed(1)}, dy=${dy.toFixed(1)}。`);

    const width = canvas.width;
    const height = canvas.height;
    const originalCtx = canvas.getContext('2d');
    const originalImageData = originalCtx.getImageData(0, 0, width, height);

    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = width;
    tmpCanvas.height = height;
    const tmpCtx = tmpCanvas.getContext('2d');
    tmpCtx.fillStyle = 'white';
    tmpCtx.fillRect(0, 0, width, height);
    tmpCtx.putImageData(originalImageData, dx, dy);

    originalCtx.clearRect(0, 0, width, height);
    originalCtx.drawImage(tmpCanvas, 0, 0);
  }

  function cropAreasFromCanvas(canvas, questionOffset = 0) {
    const res = [];
    const ctx = canvas.getContext('2d');
    const areasPerSheet = QUESTION_AREAS.length;
    
    for (let i = 0; i < areasPerSheet; i++) {
      const area = QUESTION_AREAS[i];
      const questionNumber = questionOffset + i + 1;
      const w = area.x2 - area.x1;
      const h = area.y2 - area.y1;
      if (w <= 0 || h <= 0) continue;
      
      const tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = w;
      tmpCanvas.height = h;
      const tctx = tmpCanvas.getContext('2d');
      tctx.drawImage(
        canvas,
        area.x1, area.y1, w, h,
        0, 0, w, h
      );
      const dataUrl = tmpCanvas.toDataURL('image/jpeg', 0.8);
      res.push({
        id: area.id,
        questionNumber: questionNumber,
        x1: area.x1,
        y1: area.y1,
        x2: area.x2,
        y2: area.y2,
        width: w,
        height: h,
        image: dataUrl
      });
    }
    return res;
  }

  // API 调用
  async function callChatCompletion(apiBaseUrl, apiKey, model, messages) {
    const url = apiBaseUrl.replace(/\/+$/, '') + '/chat/completions';
    const body = { model, messages };
    const resp = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + apiKey
      },
      body: JSON.stringify(body)
    });
    if (!resp.ok) {
      const text = await resp.text();
      throw new Error(`HTTP ${resp.status}: ${text}`);
    }
    const data = await resp.json();
    if (!data.choices || !data.choices[0]) {
      throw new Error('API 响应中没有 choices');
    }
    const content = data.choices[0].message.content;
    if (typeof content === 'string') return content;
    if (Array.isArray(content)) {
      return content.map(part => part.text || '').join('');
    }
    return String(content ?? '');
  }

  // OCR
  async function extractTextWithVL(apiBaseUrl, apiKey, model, imageDataUrl) {
    const messages = [
      {
        role: 'user',
        content: [
          { type: 'image_url', image_url: { url: imageDataUrl } },
          {
            type: 'text',
            text: '请准确提取图像中的所有文字内容，包括数学公式和特殊符号。不要添加任何解释，直接输出文字内容。'
          }
        ]
      }
    ];
    return (await callChatCompletion(apiBaseUrl, apiKey, model, messages)).trim();
  }

  // 文本模型批阅
  async function gradeWithTextModel(apiBaseUrl, apiKey, textModel, referenceText, answerText) {
    const systemPrompt = '你是一个严格但公正的阅卷老师，将根据参考答案对学生作答进行评分。';
    const userPrompt = `
请根据下面的整份试卷的参考答案和学生作答，对本答题区域中的所有题目逐题评分。

重要说明：
1. 只要学生答案内容正确，就应该给分，不要因为涂改、字迹等形式问题扣分
2. 对于选择题（包括单选题、多选题、编号选择题如"①②③"等）：
   - 请识别题号、学生答案、标准答案、满分，评分由系统自动完成
   - 将 question_type 设为 "choice"
3. 对于主观题：
   - 踩点给分，答对要点即给分
   - 不要求答案完全一致，意思对即可
   - 将 question_type 设为 "subjective"

输出必须是 JSON 格式：

{
  "items": [
    {
      "question_number": "题号（字符串）",
      "question_type": "choice|subjective",
      "student_answer": "学生答案（选择题必填，如'ABC'或'①②③'）",
      "correct_answer": "标准答案（选择题必填，如'ABCD'或'①②③④'）",
      "score": 分数（主观题必填，选择题可省略）,
      "max_score": 满分（数字）,
      "comment": "评分说明"
    }
  ],
  "overall_comment": "对本区域作答的总体评价"
}

参考答案：
${referenceText}

学生作答：
${answerText}
`.trim();

    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ];
    const raw = await callChatCompletion(apiBaseUrl, apiKey, textModel, messages);
    return parseGradingResponse(raw);
  }

  // VL 模型批阅
  async function gradeWithVlModel(apiBaseUrl, apiKey, vlModel, referenceText, areaImageDataUrl) {
    const systemPrompt = '你是一个严格但公正的阅卷老师，将根据参考答案对学生在图像中的作答进行评分。';
    const userText = `
你将看到一张答题区域的图片（学生作答），以及整份试卷的参考答案文本。

重要说明：
1. 只要学生答案内容正确，就应该给分，不要因为涂改、字迹等形式问题扣分
2. 对于选择题（包括单选题、多选题、编号选择题如"①②③"等）：
   - 请识别题号、学生答案、标准答案、满分，评分由系统自动完成
   - 将 question_type 设为 "choice"
3. 对于主观题：
   - 踩点给分，答对要点即给分
   - 不要求答案完全一致，意思对即可
   - 将 question_type 设为 "subjective"

输出必须是 JSON 格式：

{
  "items": [
    {
      "question_number": "题号（字符串）",
      "question_type": "choice|subjective",
      "student_answer": "学生答案（选择题必填，如'ABC'或'①②③'）",
      "correct_answer": "标准答案（选择题必填，如'ABCD'或'①②③④'）",
      "score": 分数（主观题必填，选择题可省略）,
      "max_score": 满分（数字）,
      "comment": "评分说明"
    }
  ],
  "overall_comment": "对本区域作答的总体评价"
}

参考答案：
${referenceText}
`.trim();

    const messages = [
      { role: 'system', content: systemPrompt },
      {
        role: 'user',
        content: [
          { type: 'image_url', image_url: { url: areaImageDataUrl } },
          { type: 'text', text: userText }
        ]
      }
    ];
    const raw = await callChatCompletion(apiBaseUrl, apiKey, vlModel, messages);
    return parseGradingResponse(raw);
  }

  function parseGradingResponse(raw) {
    let jsonPart;
    try {
      jsonPart = extractJsonObject(raw);
    } catch (e) {
      log('警告：批阅模型返回的 JSON 解析失败，将返回空结果。');
      jsonPart = { items: [], overall_comment: '', _raw: raw };
    }
    if (!Array.isArray(jsonPart.items)) jsonPart.items = [];
    if (typeof jsonPart.overall_comment !== 'string') jsonPart.overall_comment = '';
    
    // 处理选择题自动评分
    jsonPart.items = jsonPart.items.map(item => {
      if (item.question_type === 'choice' && item.student_answer && item.correct_answer) {
        const score = gradeChoiceQuestion(
          item.student_answer,
          item.correct_answer,
          item.max_score || 10
        );
        item.score = score.score;
        item.auto_graded = true;
        if (!item.comment) {
          item.comment = score.comment;
        }
      }
      return item;
    });
    
    return {
      items: jsonPart.items,
      overall_comment: jsonPart.overall_comment,
      raw_response: raw
    };
  }

  // 选择题自动评分（新逻辑：漏选扣max{1, 总分/选项数}，向下取整）
  function gradeChoiceQuestion(studentAnswer, correctAnswer, maxScore) {
    const normalize = (str) => {
      // 支持 A-Z, a-z, 0-9, ①-⑳ 等
      return String(str).replace(/\s+/g, '').split('').filter(c => {
        const code = c.charCodeAt(0);
        return (code >= 65 && code <= 90) || // A-Z
               (code >= 97 && code <= 122) || // a-z
               (code >= 48 && code <= 57) || // 0-9
               (code >= 9312 && code <= 9331); // ①-⑳
      }).map(c => {
        const code = c.charCodeAt(0);
        if (code >= 97 && code <= 122) return c.toUpperCase(); // a-z -> A-Z
        return c;
      }).sort().join('');
    };
    
    const student = normalize(studentAnswer);
    const correct = normalize(correctAnswer);
    
    if (!student) {
      return { score: 0, comment: '未作答，得0分' };
    }
    
    if (student === correct) {
      return { score: maxScore, comment: '答案完全正确，得满分' };
    }
    
    const studentSet = new Set(student.split(''));
    const correctSet = new Set(correct.split(''));
    
    // 检查是否有错选
    for (const opt of studentSet) {
      if (!correctSet.has(opt)) {
        return { score: 0, comment: `选项包含错误答案 ${opt}，得0分` };
      }
    }
    
    // 计算漏选
    const missing = [...correctSet].filter(opt => !studentSet.has(opt));
    if (missing.length > 0) {
      // 漏选一个扣 max{1, 总分/选项数}，向下取整
      const deductionPerMissing = Math.max(1, Math.floor(maxScore / correctSet.size));
      const totalDeduction = deductionPerMissing * missing.length;
      const score = Math.max(0, maxScore - totalDeduction);
      return { 
        score, 
        comment: `漏选 ${missing.join('')}（${missing.length}个），每个扣${deductionPerMissing}分，共扣${totalDeduction}分，得${score}分` 
      };
    }
    
    return { score: 0, comment: '答案有误，得0分' };
  }

  function extractJsonObject(str) {
    const first = str.indexOf('{');
    const last = str.lastIndexOf('}');
    if (first === -1 || last === -1 || last <= first) {
      throw new Error('No JSON object found in string');
    }
    const sub = str.slice(first, last + 1);
    return JSON.parse(sub);
  }

  function cleanQuestionNumber(questionNumber) {
    if (typeof questionNumber !== 'string') return questionNumber;
    return questionNumber.replace(/[\.。\s]+$/g, '').trim();
  }

  // 获取得分颜色（红-黄-绿三色插值）
  function getScoreColor(score, maxScore) {
    if (maxScore === 0) return '#94a3b8';
    const ratio = Math.max(0, Math.min(1, score / maxScore));
    
    let r, g, b;
    
    if (ratio <= 0.5) {
      // 0-50%: 红色 #ef4444 (239, 68, 68) -> 黄色 #f59e0b (245, 158, 11)
      const t = ratio * 2; // 映射到 0-1
      r = Math.round(239 + (245 - 239) * t);
      g = Math.round(68 + (158 - 68) * t);
      b = Math.round(68 + (11 - 68) * t);
    } else {
      // 50-100%: 黄色 #f59e0b (245, 158, 11) -> 绿色 #22c55e (34, 197, 94)
      const t = (ratio - 0.5) * 2; // 映射到 0-1
      r = Math.round(245 + (34 - 245) * t);
      g = Math.round(158 + (197 - 158) * t);
      b = Math.round(11 + (94 - 11) * t);
    }
    
    return `rgb(${r}, ${g}, ${b})`;
  }

  // ===== 批阅主流程 =====
  async function startGrading() {
    try {
      // 重置状态
      gradingResult = null;
      gradedSheetDataUrls = [];
      currentQuestionList = [];
      questionsGrid.innerHTML = '';
      selectedQuestionInfo.textContent = '点击上方某个题目方块查看详细信息';
      selectedAreaImage.src = '';
      selectedAreaImage.removeAttribute('src');
      selectedAreaText.value = '';
      selectedAreaComment.value = '';
      selectedOverallComment.value = '';
      if (gradedSheetPreview) gradedSheetPreview.src = '';
      clearOverlay();
      logDiv.textContent = '';
      updateScoreProgress(0, 0, 0);
      areaImagesMap.clear();

      // 验证配置
      const apiBaseUrl = apiBaseUrlInput.value.trim();
      const apiKey = apiKeyInput.value.trim();
      if (!apiBaseUrl || !apiKey) {
        alert('请先填写 API Base URL 和 API Key。');
        return;
      }

      const mode = Array.from(modeRadios).find(r => r.checked).value;

      let referenceOcrModel = null;
      let answerOcrModel = null;
      let textGradingModel = null;
      let vlGradingModel = null;

      if (mode === 'two-step') {
        referenceOcrModel = referenceOcrModelInput.value.trim();
        answerOcrModel = answerOcrModelInput.value.trim();
        textGradingModel = textGradingModelInput.value.trim();
        if (!answerOcrModel || !textGradingModel) {
          alert('两阶段模式下，请填写相关模型名称。');
          return;
        }
      } else {
        referenceOcrModel = referenceOcrModelVlInput.value.trim();
        vlGradingModel = vlGradingModelInput.value.trim();
        if (!vlGradingModel) {
          alert('单一 VL 模式下，请填写批阅模型（VL）。');
          return;
        }
      }

      const answerFiles = answerImageInput.files;
      if (answerFiles.length === 0) {
        alert('请上传至少一张学生答题卡图片。');
        return;
      }

      const questionCount = parseInt(questionCountInput.value) || 12;

      startButton.disabled = true;
      downloadJsonButton.disabled = true;
      downloadGradedSheetButton.disabled = true;
      log('开始处理答题卡…');

      // 获取参考答案
      const manualRef = referenceTextManualInput.value.trim();
      let referenceText = manualRef;

      if (!referenceText) {
        const referenceFiles = referenceImageInput.files;
        if (referenceFiles.length === 0) {
          alert('请上传参考答案图片或手动填写参考答案文本。');
          startButton.disabled = false;
          return;
        }

        if (!referenceOcrModel) {
          alert('请填写参考答案 OCR 模型。');
          startButton.disabled = false;
          return;
        }

        log(`加载 ${referenceFiles.length} 张参考答案图片…`);
        referenceImageDataUrls = [];
        for (let i = 0; i < referenceFiles.length; i++) {
          log(`处理参考图片 ${i + 1}/${referenceFiles.length}: ${referenceFiles[i].name}`);
          const dataUrl = await readFileAsDataURL(referenceFiles[i]);
          referenceImageDataUrls.push(dataUrl);
          
          log(`使用模型 ${referenceOcrModel} 对参考图片 ${i + 1} 进行 OCR…`);
          const pageText = await extractTextWithVL(apiBaseUrl, apiKey, referenceOcrModel, dataUrl);
          referenceText += (referenceText ? '\n\n' : '') + pageText;
          log(`参考图片 ${i + 1} OCR 完成，长度 ${pageText.length}。`);
        }
      } else {
        log('使用手动输入的参考答案文本。');
      }
      
      currentReferenceText = referenceText;
      log('参考答案准备完成（仅展示前 120 字）：\n' + referenceText.slice(0, 120) + (referenceText.length > 120 ? '…' : ''));

      // 处理答题卡
      answerSheetDataUrls = [];
      allAreaImages = [];
      let questionOffset = 0;
      const areasPerSheet = QUESTION_AREAS.length;

      for (let fileIdx = 0; fileIdx < answerFiles.length; fileIdx++) {
        if (questionOffset >= questionCount) {
          log(`已达到批阅题数限制 (${questionCount} 题)，停止处理后续答题卡。`);
          break;
        }

        const file = answerFiles[fileIdx];
        log(`\n处理答题卡 ${fileIdx + 1}/${answerFiles.length}: ${file.name}`);
        
        const dataUrl = await readFileAsDataURL(file);
        answerSheetDataUrls.push({ original: dataUrl });
        
        const img = await loadImage(dataUrl);
        const tmpCanvas = document.createElement('canvas');
        drawImageToCanvas(img, tmpCanvas);
        
        alignCanvas(tmpCanvas);
        const alignedDataUrl = tmpCanvas.toDataURL('image/jpeg', 0.9);
        answerSheetDataUrls[fileIdx].aligned = alignedDataUrl;
        
        const areas = cropAreasFromCanvas(tmpCanvas, questionOffset);
        const remainingQuestions = questionCount - questionOffset;
        const areasToUse = areas.slice(0, remainingQuestions);
        
        allAreaImages.push(...areasToUse.map(area => ({
          ...area,
          sheetIndex: fileIdx
        })));
        
        questionOffset += areasToUse.length;
        log(`答题卡 ${fileIdx + 1} 处理完成，裁剪了 ${areasToUse.length} 个区域。`);
      }

      log(`\n共裁剪 ${allAreaImages.length} 个答题区域，开始批阅…`);

      if (answerSheetDataUrls.length > 0 && answerSheetDataUrls[0].aligned) {
        const img = await loadImage(answerSheetDataUrls[0].aligned);
        drawImageToCanvas(img, answerCanvas);
        syncOverlayCanvasSize();
      }

      // 批阅所有区域
      const allItems = [];
      const areaSummaries = [];
      let globalIndex = 1;

      for (const area of allAreaImages) {
        log(`\n==== 开始批阅题目 ${area.questionNumber} (区域 #${area.id}, 答题卡 ${area.sheetIndex + 1}) ====`);
        let extractedText = null;
        let gradingRes = null;
        const start = performance.now();

        if (mode === 'two-step') {
          log(`题目 ${area.questionNumber}: 使用 ${answerOcrModel} 进行 OCR…`);
          extractedText = await extractTextWithVL(apiBaseUrl, apiKey, answerOcrModel, area.image);
          log(`题目 ${area.questionNumber}: OCR 完成，长度 ${extractedText.length}。`);

          log(`题目 ${area.questionNumber}: 使用文本模型 ${textGradingModel} 进行批阅…`);
          gradingRes = await gradeWithTextModel(apiBaseUrl, apiKey, textGradingModel, referenceText, extractedText);
        } else {
          log(`题目 ${area.questionNumber}: 使用 VL 模型 ${vlGradingModel} 直接批阅…`);
          gradingRes = await gradeWithVlModel(apiBaseUrl, apiKey, vlGradingModel, referenceText, area.image);
        }

        const elapsed = ((performance.now() - start) / 1000).toFixed(2);
        log(`题目 ${area.questionNumber}: 批阅完成，耗时 ${elapsed} 秒。`);

        for (const item of gradingRes.items) {
          const cleanedQuestionNumber = cleanQuestionNumber(String(item.question_number ?? '').trim());
          
          allItems.push({
            index: globalIndex++,
            question_number: cleanedQuestionNumber,
            question_type: item.question_type || 'subjective',
            student_answer: item.student_answer || '',
            correct_answer: item.correct_answer || '',
            score: Number(item.score ?? 0),
            max_score: Number(item.max_score ?? 10),
            comment: String(item.comment ?? ''),
            auto_graded: item.auto_graded || false,
            area_id: area.id,
            sheet_index: area.sheetIndex,
            area_coords: [area.x1, area.y1, area.x2, area.y2],
            extracted_text: extractedText,
            area_image: area.image
          });
        }
        
        areaSummaries.push({
          area_id: area.id,
          sheet_index: area.sheetIndex,
          question_number: area.questionNumber,
          overall_comment: gradingRes.overall_comment || '',
          raw_response: gradingRes.raw_response
        });
      }

      gradingResult = {
        created_at: new Date().toISOString(),
        api: {
          base_url: apiBaseUrl,
          grading_mode: mode,
          reference_ocr_model: referenceOcrModel,
          answer_ocr_model: answerOcrModel,
          text_grading_model: textGradingModel,
          vl_grading_model: vlGradingModel
        },
        reference: {
          images: referenceImageDataUrls,
          text: referenceText
        },
        answer_sheets: answerSheetDataUrls,
        grading: {
          items: allItems,
          area_summaries: areaSummaries
        }
      };

      renderGradingResult(gradingResult);
      downloadJsonButton.disabled = false;
      await generateGradedAnswerSheets();
      downloadGradedSheetButton.disabled = false;
      log('\n全部批阅完成。');
    } catch (err) {
      console.error(err);
      log('错误：' + err.message);
      alert('发生错误：' + err.message);
    } finally {
      startButton.disabled = false;
    }
  }

  // 生成批阅后答题卡
  async function generateGradedAnswerSheets() {
    // helper: rounded rect
    function roundRect(ctxx, x, y, w, h, r, fill, stroke) {
      if (typeof r === 'undefined') r = 5;
      if (r > w / 2) r = w / 2;
      if (r > h / 2) r = h / 2;
      ctxx.beginPath();
      ctxx.moveTo(x + r, y);
      ctxx.arcTo(x + w, y, x + w, y + h, r);
      ctxx.arcTo(x + w, y + h, x, y + h, r);
      ctxx.arcTo(x, y + h, x, y, r);
      ctxx.arcTo(x, y, x + w, y, r);
      ctxx.closePath();
      if (fill) ctxx.fill();
      if (stroke) ctxx.stroke();
    }

    try {
      gradedSheetDataUrls = [];
      gradedScoreOnlyDataUrls = [];
      if (gradedSheetPreview) gradedSheetPreview.src = '';

      if (!gradingResult) return;

      const items = gradingResult.grading.items || [];

      // 兼容旧格式和新格式
      let sheets = [];
      if (gradingResult.answer_sheets) {
        sheets = gradingResult.answer_sheets;
      } else if (gradingResult.answer_sheet) {
        sheets = [{
          original: gradingResult.answer_sheet.original_image,
          aligned: gradingResult.answer_sheet.aligned_image
        }];
      }

      // 按 area_id 聚合 items，便于在每个区域右侧绘制该区域的小题评分列表
      const areaMap = new Map();
      for (const it of items) {
        if (it.sheet_index !== undefined && it.sheet_index !== undefined) {
          // 保持原有 sheet_index 使用（后面按 sheet 划分时会以 item.sheet_index 为准）
        }
        const key = it.area_id;
        if (!areaMap.has(key)) areaMap.set(key, []);
        areaMap.get(key).push(it);
      }

      // 全局排序所有题目，与 renderGradingResult 保持一致
      const sortedItems = [...items].sort((a, b) => {
        const na = parseInt(a.question_number, 10);
        const nb = parseInt(b.question_number, 10);
        if (!isNaN(na) && !isNaN(nb)) {
          return na - nb;
        }
        return String(a.question_number).localeCompare(String(b.question_number), 'zh-CN');
      });

      for (let sheetIdx = 0; sheetIdx < sheets.length; sheetIdx++) {
        const sheet = sheets[sheetIdx];
        const baseUrl = sheet.aligned || sheet.original;
        if (!baseUrl) continue;

        const img = baseUrl ? await loadImage(baseUrl) : null;
        const width = img ? img.naturalWidth : 2480;
        const height = img ? img.naturalHeight : 3508;

        const c = document.createElement('canvas');
        c.width = width;
        c.height = height;
        const ctx = c.getContext('2d');
        if (img) ctx.drawImage(img, 0, 0);

        const cs = document.createElement('canvas');
        cs.width = width;
        cs.height = height;
        const ctxs = cs.getContext('2d');
        ctxs.fillStyle = '#ffffff';
        ctxs.fillRect(0, 0, cs.width, cs.height);

        const padding = 8;
        const lineHeight = 26;
        const boxGap = 6;
        ctx.font = '24px system-ui';
        ctx.textBaseline = 'top';
        ctxs.font = ctx.font;
        ctxs.textBaseline = 'top';

        const itemAreaCoordsMap = new Map();
        for (const [areaId, areaItems] of areaMap) {
          let areaCoords = null;
          if (gradingResult.answer_sheets && gradingResult.answer_sheets[sheetIdx] && gradingResult.answer_sheets[sheetIdx].areas) {
            const areaDef = gradingResult.answer_sheets[sheetIdx].areas.find(a => a.id === areaId || String(a.id) === String(areaId));
            if (areaDef && areaDef.coords) {
              areaCoords = areaDef.coords;
            } else if (areaDef && areaDef.x1 !== undefined) {
              areaCoords = [areaDef.x1, areaDef.y1, areaDef.x2, areaDef.y2];
            }
          }
          if (!areaCoords) {
            const itemWithCoords = areaItems.find(it => it.area_coords && it.area_coords.length === 4);
            if (itemWithCoords) areaCoords = itemWithCoords.area_coords;
          }
          if (!areaCoords && typeof QUESTION_AREAS !== 'undefined') {
            const q = QUESTION_AREAS.find(a => String(a.id) === String(areaId));
            if (q && q.x1 !== undefined) areaCoords = [q.x1, q.y1, q.x2, q.y2];
          }
          if (areaCoords) {
            for (const item of areaItems) {
              itemAreaCoordsMap.set(item, areaCoords);
            }
          }
        }

        let currentY = 10;

        for (const item of sortedItems) {
          const areaCoords = itemAreaCoordsMap.get(item);
          if (!areaCoords) continue;

          const line = `${item.question_number}:${item.score}/${item.max_score}`;

          const measureCtx = ctx;
          const lineWidth = Math.ceil(measureCtx.measureText(line).width + padding * 2);
          const lineHeightBox = lineHeight + padding * 2;

          const tx = Math.round((c.width - lineWidth) / 2);
          const ty = currentY;

          currentY += lineHeightBox + boxGap;

          const itemScore = Number(item.score) || 0;
          const itemMax = Number(item.max_score) || 1;
          const fillColor = getScoreColor(itemScore, itemMax);

          ctx.save();
          ctx.fillStyle = fillColor;
          ctx.globalAlpha = 0.15;
          roundRect(ctx, tx, ty, lineWidth, lineHeightBox, 6, true, false);
          ctx.globalAlpha = 1;
          ctx.strokeStyle = fillColor;
          ctx.lineWidth = 2;
          roundRect(ctx, tx + 1, ty + 1, lineWidth - 2, lineHeightBox - 2, 6, false, true);
          ctx.fillStyle = '#0b1220';
          ctx.font = '24px system-ui';
          ctx.fillText(line, tx + padding, ty + padding);
          ctx.restore();

          ctxs.save();
          ctxs.fillStyle = fillColor;
          ctxs.globalAlpha = 0.12;
          roundRect(ctxs, tx, ty, lineWidth, lineHeightBox, 6, true, false);
          ctxs.globalAlpha = 1;
          ctxs.strokeStyle = fillColor;
          ctxs.lineWidth = 2;
          roundRect(ctxs, tx + 1, ty + 1, lineWidth - 2, lineHeightBox - 2, 6, false, true);
          ctxs.fillStyle = '#0b1220';
          ctxs.font = '24px system-ui';
          ctxs.fillText(line, tx + padding, ty + padding);
          ctxs.restore();
        }

        // 在右上方绘制总分信息
        const totalScore = sortedItems.reduce((s, it) => s + (Number(it.score) || 0), 0);
        const totalMax = sortedItems.reduce((s, it) => s + (Number(it.max_score) || 0), 0);
        const percentage = totalMax > 0 ? (totalScore / totalMax * 100) : 0;
        const scoreStr = totalScore.toFixed(1);
        const maxStr = totalMax.toFixed(1);
        const percentStr = `(${percentage.toFixed(1)}%)`;

        ctx.save();
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#dc2626';
        const scoreMargin = 20;
        
        // 绘制百分比（大字体）
        ctx.font = 'bold 56px system-ui';
        ctx.fillText(percentStr, c.width - scoreMargin, scoreMargin);
        const percentWidth = ctx.measureText(percentStr).width;
        
        // 绘制总分（小字体）
        ctx.font = 'bold 32px system-ui';
        const totalText = `/${maxStr}`;
        ctx.fillText(totalText, c.width - scoreMargin - percentWidth - 15, scoreMargin + 10);
        const totalWidth = ctx.measureText(totalText).width;
        
        // 绘制得分（大字体）
        ctx.font = 'bold 56px system-ui';
        ctx.fillText(scoreStr, c.width - scoreMargin - percentWidth - totalWidth - 15, scoreMargin);
        ctx.restore();

        ctxs.save();
        ctxs.textAlign = 'right';
        ctxs.textBaseline = 'top';
        ctxs.fillStyle = '#dc2626';
        
        // 绘制百分比（大字体）
        ctxs.font = 'bold 56px system-ui';
        ctxs.fillText(percentStr, cs.width - scoreMargin, scoreMargin);
        const percentWidth2 = ctxs.measureText(percentStr).width;
        
        // 绘制总分（小字体）
        ctxs.font = 'bold 32px system-ui';
        const totalText2 = `/${maxStr}`;
        ctxs.fillText(totalText2, cs.width - scoreMargin - percentWidth2 - 15, scoreMargin + 10);
        const totalWidth2 = ctxs.measureText(totalText2).width;
        
        // 绘制得分（大字体）
        ctxs.font = 'bold 56px system-ui';
        ctxs.fillText(scoreStr, cs.width - scoreMargin - percentWidth2 - totalWidth2 - 15, scoreMargin);
        ctxs.restore();

        // 导出 dataURL
        gradedSheetDataUrls.push(c.toDataURL('image/jpeg', 0.9));
        gradedScoreOnlyDataUrls.push(cs.toDataURL('image/jpeg', 0.9));
      }

      // 默认在预览中显示第一张（或空）
      const modeSelect = document.getElementById('gradedModeSelect');
      if (modeSelect) {
        const sel = modeSelect.value || 'sheet';
        if (sel === 'scores' && gradedScoreOnlyDataUrls[0]) {
          gradedSheetPreview.src = gradedScoreOnlyDataUrls[0];
        } else if (gradedSheetDataUrls[0]) {
          gradedSheetPreview.src = gradedSheetDataUrls[0];
        } else {
          gradedSheetPreview.removeAttribute('src');
        }
      } else {
        if (gradedSheetDataUrls[0]) gradedSheetPreview.src = gradedSheetDataUrls[0];
      }
    } catch (err) {
      console.error('生成批阅后答题卡失败:', err);
    }
  }

  // 切换预览模式（带背景 / 仅评分）
  const gradedModeSelectEl = document.getElementById('gradedModeSelect');
  if (gradedModeSelectEl) {
    gradedModeSelectEl.addEventListener('change', () => {
      const v = gradedModeSelectEl.value;
      if (v === 'scores') {
        if (gradedScoreOnlyDataUrls && gradedScoreOnlyDataUrls[0]) gradedSheetPreview.src = gradedScoreOnlyDataUrls[0];
        else if (gradedSheetDataUrls && gradedSheetDataUrls[0]) gradedSheetPreview.src = gradedSheetDataUrls[0];
      } else {
        if (gradedSheetDataUrls && gradedSheetDataUrls[0]) gradedSheetPreview.src = gradedSheetDataUrls[0];
        else if (gradedScoreOnlyDataUrls && gradedScoreOnlyDataUrls[0]) gradedSheetPreview.src = gradedScoreOnlyDataUrls[0];
      }
    });
  }

  // 更新总分进度条
  function updateScoreProgress(score, maxScore, count) {
    const percentage = maxScore > 0 ? (score / maxScore * 100) : 0;
    scoreProgressFill.style.width = percentage + '%';
    scoreProgressText.textContent = `${score.toFixed(1)} / ${maxScore.toFixed(1)}`;
    scoreStatsLeft.textContent = `得分率: ${percentage.toFixed(1)}%`;
    scoreStatsRight.textContent = `已批阅: ${count} 题`;
  }

  // 渲染批阅结果
  function renderGradingResult(result) {
    const items = result.grading.items || [];
    
    const sorted = [...items].sort((a, b) => {
      const na = parseInt(a.question_number, 10);
      const nb = parseInt(b.question_number, 10);
      if (!isNaN(na) && !isNaN(nb)) {
        return na - nb;
      }
      return String(a.question_number).localeCompare(String(b.question_number), 'zh-CN');
    });

    currentQuestionList = sorted;
    
    const totalScore = sorted.reduce((s, it) => s + (it.score || 0), 0);
    const totalMaxScore = sorted.reduce((s, it) => s + (it.max_score || 0), 0);
    
    updateScoreProgress(totalScore, totalMaxScore, sorted.length);

    questionsGrid.innerHTML = '';
    sorted.forEach((item, idx) => {
      const card = document.createElement('div');
      card.className = 'question-card';
      card.dataset.index = String(idx);
      
      const questionNum = document.createElement('div');
      questionNum.className = 'question-number';
      questionNum.textContent = `${item.question_number}`;
      
      const scoreDiv = document.createElement('div');
      scoreDiv.className = 'question-score';
      scoreDiv.textContent = `${item.score || 0}`;
      scoreDiv.style.color = getScoreColor(item.score || 0, item.max_score || 10);
      
      const typeDiv = document.createElement('div');
      typeDiv.className = 'question-type';
      typeDiv.textContent = `满分: ${item.max_score || 10}`;
      
      card.appendChild(questionNum);
      card.appendChild(scoreDiv);
      card.appendChild(typeDiv);
      
      card.addEventListener('click', () => onQuestionCardClick(card, item, result));
      questionsGrid.appendChild(card);
    });
  }

  function onQuestionCardClick(card, item, result) {
    if (selectedCardElement) {
      selectedCardElement.classList.remove('selected');
    }
    selectedCardElement = card;
    card.classList.add('selected');

    selectedQuestionInfo.textContent =
      `题号：${item.question_number}，得分：${item.score}/${item.max_score}` +
      (item.question_type === 'choice' ? '（选择题）' : '（主观题）') +
      (item.auto_graded ? '（系统自动评分）' : '');

    // 获取图片 - 兼容新旧格式
    let areaImageUrl = null;
    
    // 优先使用 item.area_image（新格式）
    if (item.area_image && typeof item.area_image === 'string' && item.area_image.startsWith('data:image')) {
      areaImageUrl = item.area_image;
    } 
    // 然后尝试从 areaImagesMap 获取（旧格式加载的数据）
    else if (areaImagesMap.has(item.area_id)) {
      areaImageUrl = areaImagesMap.get(item.area_id);
    }
    // 最后尝试从 result.answer_sheet.areas 获取（旧格式）
    else if (result.answer_sheet && result.answer_sheet.areas) {
      const area = result.answer_sheet.areas.find(a => a.id === item.area_id);
      if (area && area.image) {
        areaImageUrl = area.image;
        areaImagesMap.set(item.area_id, area.image); // 缓存
      }
    }
    
    if (areaImageUrl) {
      selectedAreaImage.setAttribute('src', areaImageUrl);
      
      // 高亮对应区域
      if (item.area_coords) {
        // 获取答题卡图片
        let sheetImageUrl = null;
        if (item.sheet_index !== undefined && answerSheetDataUrls[item.sheet_index]) {
          const sheetData = answerSheetDataUrls[item.sheet_index];
          sheetImageUrl = sheetData.aligned || sheetData.original;
        } else if (result.answer_sheet) {
          // 旧格式
          sheetImageUrl = result.answer_sheet.aligned_image || result.answer_sheet.original_image;
        }
        
        if (sheetImageUrl) {
          loadImage(sheetImageUrl).then(img => {
            drawImageToCanvas(img, answerCanvas);
            syncOverlayCanvasSize();
            const [x1, y1, x2, y2] = item.area_coords;
            drawAreaHighlight({x1, y1, x2, y2});
          }).catch((err) => {
            console.error('加载答题卡图片失败:', err);
          });
        }
      }
    } else {
      selectedAreaImage.removeAttribute('src');
      clearOverlay();
    }
    
    let displayText = item.extracted_text || '';
    if (item.question_type === 'choice') {
      displayText = `学生答案: ${item.student_answer || '未作答'}\n标准答案: ${item.correct_answer || '未知'}\n\n${displayText}`;
    }
    selectedAreaText.value = displayText;
    
    selectedAreaComment.value = item.comment || '';
    
    // 显示区域整体评价
    let overallComment = '';
    if (result && result.grading && result.grading.area_summaries) {
      const summary = result.grading.area_summaries.find(s => {
        if (s.sheet_index !== undefined && item.sheet_index !== undefined) {
          return s.area_id === item.area_id && s.sheet_index === item.sheet_index;
        }
        return s.area_id === item.area_id;
      });
      if (summary && summary.overall_comment) {
        overallComment = summary.overall_comment;
      }
    }
    selectedOverallComment.value = overallComment;
  }

  // 下载 JSON
  function downloadJson() {
    if (!gradingResult) {
      alert('当前没有批阅结果可导出。');
      return;
    }
    const ts = new Date().toISOString().replace(/[:.-]/g, '').slice(0, 15);
    const filename = `grading_result_${ts}.json`;
    const blob = new Blob([JSON.stringify(gradingResult, null, 2)], { type: 'application/json' });
    downloadBlob(blob, filename);
  }

  // 下载批阅后答题卡
  function downloadGradedSheet() {
    if (gradedSheetDataUrls.length === 0) {
      alert('尚未生成批阅后的答题卡。');
      return;
    }
    
    if (gradedSheetDataUrls.length === 1) {
      const ts = new Date().toISOString().replace(/[:.-]/g, '').slice(0, 15);
      const a = document.createElement('a');
      a.href = gradedSheetDataUrls[0];
      a.download = `graded_answer_sheet_${ts}.jpg`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } else {
      gradedSheetDataUrls.forEach((dataUrl, idx) => {
        const ts = new Date().toISOString().replace(/[:.-]/g, '').slice(0, 15);
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `graded_answer_sheet_${ts}_${idx + 1}.jpg`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      });
    }
  }

  // 下载模板PDF
  function downloadPresetTemplatePdf() {
    const a = document.createElement('a');
    a.href = '/answer_sheet.pdf';
    a.download = 'answer_sheet.pdf';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // 从 JSON 加载 - 兼容新旧格式
  function loadGradingResultFromObject(obj) {
    gradingResult = obj;
    areaImagesMap.clear();
    
    if (obj.reference && obj.reference.text) {
      currentReferenceText = obj.reference.text;
    }
    
    // 兼容旧格式：将 answer_sheet 转换为 answer_sheets
    if (obj.answer_sheet && !obj.answer_sheets) {
      log('检测到旧版JSON格式，正在转换...');
      answerSheetDataUrls = [{
        original: obj.answer_sheet.original_image,
        aligned: obj.answer_sheet.aligned_image
      }];
      
      // 缓存旧格式的区域图片
      if (obj.answer_sheet.areas) {
        obj.answer_sheet.areas.forEach(area => {
          if (area.id && area.image) {
            areaImagesMap.set(area.id, area.image);
          }
        });
      }
      
      // 确保items有area_image字段（从areas中获取）
      if (obj.grading && obj.grading.items) {
        obj.grading.items = obj.grading.items.map(item => {
          if (!item.area_image && item.area_id) {
            const area = obj.answer_sheet.areas.find(a => a.id === item.area_id);
            if (area && area.image) {
              item.area_image = area.image;
            }
          }
          // 旧格式没有 sheet_index，设为 undefined 或 0
          if (item.sheet_index === undefined) {
            item.sheet_index = 0;
          }
          return item;
        });
      }
      
      log('旧版JSON格式转换完成');
    } else if (obj.answer_sheets) {
      answerSheetDataUrls = obj.answer_sheets;
    }
    
    renderGradingResult(obj);
    downloadJsonButton.disabled = false;
    
    // 显示第一张答题卡
    if (answerSheetDataUrls.length > 0) {
      const firstSheet = answerSheetDataUrls[0];
      const img = firstSheet.aligned || firstSheet.original;
      if (img) {
        loadImage(img).then(image => {
          drawImageToCanvas(image, answerCanvas);
          syncOverlayCanvasSize();
        }).catch(() => {});
      }
    } else if (obj.answer_sheet) {
      // 旧格式
      const img = obj.answer_sheet.aligned_image || obj.answer_sheet.original_image;
      if (img) {
        loadImage(img).then(image => {
          drawImageToCanvas(image, answerCanvas);
          syncOverlayCanvasSize();
        }).catch(() => {});
      }
    }
    
    generateGradedAnswerSheets();
    log('已从 JSON 加载批阅结果。');
  }

  async function loadJsonFromFileInput(file) {
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      loadGradingResultFromObject(obj);
    } catch (e) {
      alert('解析 JSON 文件失败：' + e.message);
    }
  }

  async function loadJsonFromUrl(url) {
    try {
      log(`尝试从 URL 加载 JSON：${url}`);
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }
      const obj = await resp.json();
      loadGradingResultFromObject(obj);
    } catch (e) {
      log('从 URL 加载 JSON 失败：' + e.message);
    }
  }

  // 设置保存/恢复
  function saveSettingsToLocalStorage() {
    const cfg = {
      apiBaseUrl: apiBaseUrlInput.value.trim(),
      apiKey: apiKeyInput.value,
      referenceOcrModel: referenceOcrModelInput.value.trim(),
      referenceOcrModelVl: referenceOcrModelVlInput.value.trim(),
      answerOcrModel: answerOcrModelInput.value.trim(),
      textGradingModel: textGradingModelInput.value.trim(),
      vlGradingModel: vlGradingModelInput.value.trim(),
      mode: Array.from(modeRadios).find(r => r.checked).value,
      enableAlign: enableAlignCheckbox.checked,
      questionCount: questionCountInput.value
    };
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(cfg));
    log('已将设置保存到浏览器本地。');
  }

  function loadSettingsFromLocalStorage() {
    try {
      const data = localStorage.getItem(SETTINGS_KEY);
      if (!data) return;
      const cfg = JSON.parse(data);
      if (cfg.apiBaseUrl) apiBaseUrlInput.value = cfg.apiBaseUrl;
      if (typeof cfg.apiKey === 'string') apiKeyInput.value = cfg.apiKey;
      if (cfg.referenceOcrModel) referenceOcrModelInput.value = cfg.referenceOcrModel;
      if (cfg.referenceOcrModelVl) referenceOcrModelVlInput.value = cfg.referenceOcrModelVl;
      if (cfg.answerOcrModel) answerOcrModelInput.value = cfg.answerOcrModel;
      if (cfg.textGradingModel) textGradingModelInput.value = cfg.textGradingModel;
      if (cfg.vlGradingModel) vlGradingModelInput.value = cfg.vlGradingModel;
      if (typeof cfg.enableAlign === 'boolean') enableAlignCheckbox.checked = cfg.enableAlign;
      if (cfg.questionCount) questionCountInput.value = cfg.questionCount;
      if (cfg.mode) {
        modeRadios.forEach(r => { r.checked = (r.value === cfg.mode); });
        updateModeDisplay(cfg.mode);
      }
      log('已从浏览器本地加载设置。');
    } catch (e) {
      console.warn('加载设置失败：', e);
    }
  }

  function clearSettingsFromLocalStorage() {
    localStorage.removeItem(SETTINGS_KEY);
    apiBaseUrlInput.value = '';
    apiKeyInput.value = '';
    referenceOcrModelInput.value = '';
    referenceOcrModelVlInput.value = '';
    answerOcrModelInput.value = '';
    textGradingModelInput.value = '';
    vlGradingModelInput.value = '';
    enableAlignCheckbox.checked = true;
    questionCountInput.value = '12';
    modeRadios.forEach(r => { r.checked = (r.value === 'two-step'); });
    updateModeDisplay('two-step');
    log('已清除本地保存的设置。');
  }

  function updateModeDisplay(mode) {
    if (mode === 'two-step') {
      twoStepConfig.style.display = '';
      singleVlConfig.style.display = 'none';
    } else {
      twoStepConfig.style.display = 'none';
      singleVlConfig.style.display = '';
    }
  }

  // 事件绑定
  startButton.addEventListener('click', startGrading);
  downloadJsonButton.addEventListener('click', downloadJson);
  downloadGradedSheetButton.addEventListener('click', downloadGradedSheet);
  downloadTemplatePdfButton.addEventListener('click', downloadPresetTemplatePdf);

  showReferenceTextButton.addEventListener('click', showReferenceTextModal);
  saveReferenceTextButton.addEventListener('click', saveReferenceText);

  closeReferenceModal.addEventListener('click', () => closeModal(referenceTextModal));
  closeReferenceTextModal.addEventListener('click', () => closeModal(referenceTextModal));
  copyReferenceTextButton.addEventListener('click', copyReferenceText);

  jsonFileInput.addEventListener('change', () => {
    const file = jsonFileInput.files[0];
    if (file) loadJsonFromFileInput(file);
  });

  answerImageInput.addEventListener('change', () => updateFileList(answerImageInput, answerFileList));
  referenceImageInput.addEventListener('change', () => updateFileList(referenceImageInput, referenceFileList));

  modeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const mode = Array.from(modeRadios).find(r => r.checked).value;
      updateModeDisplay(mode);
    });
  });

  saveSettingsButton.addEventListener('click', saveSettingsToLocalStorage);
  clearSettingsButton.addEventListener('click', clearSettingsFromLocalStorage);

  window.addEventListener('click', (event) => {
    if (event.target === referenceTextModal) {
      closeModal(referenceTextModal);
    }
  });

  window.addEventListener('load', () => {
    loadSettingsFromLocalStorage();
    updateFileList(answerImageInput, answerFileList);
    updateFileList(referenceImageInput, referenceFileList);
    const params = new URLSearchParams(window.location.search);
    const file = params.get('file');
    if (file) {
      loadJsonFromUrl(file);
    }
  });
</script>
</body>
</html>